# 1. Building The Math Bounty dApp Off-Chain Library

In this tutorial series we will be building a simple "Math Bounty" dApp using the Ergo Protocol Framework. In short, this dApp allows individuals to lock Ergs up under a contract which requires a person to solve the math problem encoded in the contract in order to withdraw the funds inside. The idea for this dApp originally came from [this Ergo Forum Thread](https://www.ergoforum.org/t/mathematical-fun-with-ergoscript/76).

In our case we'll be using a simpler problem/contract to make it easy to follow along. Do note that this dApp isn't 100% secure because either because you can be front-run by others who are watching the mempool. Nonetheless, this is an instructive example that you will be able to run live on mainnet. (Refer to the above linked thread for more details about how to make a more complicated, but secure Math Bounty smart contract)

## The Smart Contract

Before we dive into building the off-chain portion of our dApp, let's take a look at the contract we'll be using.

```scala
{
 OUTPUTS(0).R4[Long].get * 2 == 4
}
```
As can be seen, the contract is extremely simple.

In short, a user can withdraw funds if they can figure out what number multiplied by `2` is equal to `4`. Specifically, funds can be withdrawn if the output UTXO with the index 0 has a register R4, with a Long Integer in the register, and said register is equal to the number `2` (in order for the equation to be true).

Compiling this contract into a P2S address results in the address: `94hWSMqgxHtRNEWoKrJFGVNQEYX34zfX68FNxWr`. ([Clicking here to try compiling it yourself on the PlutoMonkey Playground](https://wallet.plutomonkey.com/p2s/?source=ewogSU5QVVRTKDApLlI0W0xvbmddLmdldCAqIDIgPT0gNAp9))


In the rest of this tutorial we will be writing the off-chain library for our dApp which performs all of the transaction creation logic for someone to perform the "Solve Problem" action, and thus withdraw the funds locked.


## 




First we're going to import all of the Ergo Protocol Framework structs/functions/macros to keep things simple:

```rust
use ergo_protocol_framework::*;
use ergo_lib::chain::ergo_box::ErgoBox;
```
You may have noticed that we also imported `ErgoBox` from the `ergo_lib` library. This is the Rust struct representation of an Ergo box(UTXO) which we will use shortly.


------



The next thing we are going to do is define the stages of our protocol. In our case we have a simple single-stage smart contract protocol in our dApp. This means we need to only create a single Rust stage-representing struct for our dApp.

This stage in our dApp will be called the `Math Problem` stage. As such, we will name the struct which will wrap an `ErgoBox` at this stage the `MathProblemBox`.

```rust
pub struct MathProblemBox {
    ergo_box: ErgoBox,
}
```

Now that we've defined the `MathProblemBox`, we can also derive a few traits automatically to make our lives easier:

```rust
#[derive(Debug, Clone, WrapBox)]
pub struct MathProblemBox {
    ergo_box: ErgoBox,
}
```

To the Rust-initiated, `Debug` and `Clone` are typical, but `WrapBox` is new. This is a procedural macro which automatically implements the `WrappedBox` trait for our `MathProblemBox`. In other words, we have access to new helper methods without writing any extra code ourselves.


-----

Next we are going to implement the `SpecifiedBox` trait on our `MathProblemBox`.


