# 1. Building The Math Bounty dApp Off-Chain Library

In this tutorial series we will be building a simple "Math Bounty" dApp using the Ergo Protocol Framework. In short, this dApp allows individuals to lock Ergs up under a contract which requires a person to solve the math problem encoded in the contract in order to withdraw the funds inside. The idea for this dApp originally came from [this Ergo Forum Thread](https://www.ergoforum.org/t/mathematical-fun-with-ergoscript/76).

In our case we'll be using a simpler problem/contract to make it easy to follow along. Do note that this dApp isn't 100% secure because either because you can be front-run by others who are watching the mempool. Nonetheless, this is an instructive example that you will be able to run live on mainnet. (Refer to the above linked thread for more details about how to make a more complicated, but secure Math Bounty smart contract)

## The Smart Contract

Before we dive into building the off-chain portion of our dApp, let's take a look at the contract we'll be using.

```scala
{
 OUTPUTS(0).R4[Long].get * 2 == 4
}
```
As can be seen, the contract is extremely simple.

In short, a user can withdraw funds if they can figure out what number multiplied by `2` is equal to `4`. Specifically, funds can be withdrawn if the output UTXO with the index 0 has a register R4, with a Long Integer in the register, and said register is equal to the number `2` (in order for the equation to be true).

Compiling this contract into a P2S address results in the address: `94hWSMqgxHtRNEWoKrJFGVNQEYX34zfX68FNxWr`. ([Click here to try compiling it for yourself on the PlutoMonkey Playground](https://wallet.plutomonkey.com/p2s/?source=ewogSU5QVVRTKDApLlI0W0xvbmddLmdldCAqIDIgPT0gNAp9))


In the rest of this tutorial we will be writing the off-chain library for our dApp which performs all of the transaction creation logic for someone to perform the "Solve Problem" action, and thus withdraw the funds locked.


## 




First we're going to import all of the Ergo Protocol Framework structs/functions/macros to keep things simple:

```rust
use ergo_protocol_framework::*;
use ergo_lib::chain::ergo_box::ErgoBox;
```
You may have noticed that we also imported `ErgoBox` from the `ergo_lib` library. This is the Rust struct representation of an Ergo box(UTXO) which we will use shortly.


------



The next thing we are going to do is define the stages of our protocol. In our case we have a simple single-stage smart contract protocol in our dApp. This means we need to only create a single Rust stage-representing struct for our dApp.

This stage in our dApp will be called the `Math Problem` stage. As such, we will name the struct which will wrap an `ErgoBox` at this stage the `MathProblemBox`.

```rust
pub struct MathProblemBox {
    ergo_box: ErgoBox,
}
```

Now that we've defined the `MathProblemBox`, we can also derive a few traits automatically to make our lives easier:

```rust
#[derive(Debug, Clone, WrapBox)]
pub struct MathProblemBox {
    ergo_box: ErgoBox,
}
```

To the Rust-initiated, `Debug` and `Clone` are typical, but `WrapBox` is new. This is a procedural macro which automatically implements the `WrappedBox` trait for our `MathProblemBox`. In other words, we have access to new helper methods without writing any extra code ourselves.


-----

Next we are going to implement the `SpecifiedBox` trait on our `MathProblemBox`.

```rust
impl SpecifiedBox for MathProblemBox {
    fn box_spec() -> BoxSpec {
        todo!();
    }
}
```

Now this is where things get interesting. This trait requires us to implement a method which returns a `BoxSpec`.

A `BoxSpec` is a specification in the form of a Rust struct which specifies parameters of an `ErgoBox`. This spec struct is used as a "source of truth" to both verify and find `ErgoBox`es which match the spec.

As such, we are going to create a `BoxSpec` for the Math Problem stage, which will be used by our `MathProblemBox` struct. We will be doing this using the `BoxSpec::new()` method which allows us to specify the address, value range, registers, and tokens for our specification. In our case we will only be using the address due to the simplicity of our dApp.


```rust
impl SpecifiedBox for MathProblemBox {
    fn box_spec() -> BoxSpec {
        let address = Some("94hWSMqgxHtRNEWoKrJFGVNQEYX34zfX68FNxWr".to_string());
        BoxSpec::new(address, None, vec![], vec![])
    }
}
```

Our Rust-based spec of the Math Problem stage states that an `ErgoBox` which has an address of `94hWSMqgxHtRNEWoKrJFGVNQEYX34zfX68FNxWr` is a valid `MathProblemBox`. Furthermore this means that no matter what Ergs/registers/tokens the `ErgoBox` has inside, it is still considered a valid `MathProblemBox`. For our use case, this is a valid spec for what we were going for.


---

Next up, we are going to implement the `new` method so that a `MathProblemBox` can be created.

```rust
impl MathProblemBox {
    pub fn new(ergo_box: &ErgoBox) -> Option<MathProblemBox> {
        // Using the automatically implemented `verify_box` method
        // from the `BoxSpec` to verify the `ErgoBox` is a valid
        // `MathProblemBox`.
        Self::box_spec().verify_box(ergo_box).ok()?;

        // Creating the `MathProblemBox`
        let math_problem_box = MathProblemBox {
            ergo_box: ergo_box.clone(),
        };

        // Returning the `MathProblemBox`
        Some(math_problem_box)
    }
}
```

As can be seen above, we use the `verify_box` method to ensure that the `ErgoBox` is indeed a valid `MathProblemBox` according to our spec we defined. This `verify_box` method is automatically available for use once the `SpecifiedBox` trait has been implemented for your structs.
